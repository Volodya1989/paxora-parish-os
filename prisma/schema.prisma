generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum ParishRole {
  ADMIN
  SHEPHERD
  MEMBER
}

enum PlatformRole {
  SUPERADMIN
}

enum NotificationType {
  MESSAGE
  TASK
  ANNOUNCEMENT
  EVENT
  REQUEST
  MENTION
}

enum MentionContextType {
  CHAT_MESSAGE
  TASK_COMMENT
}

enum AuditAction {
  IMPERSONATION_START
  IMPERSONATION_END
}

enum GroupRole {
  COORDINATOR
  PARISHIONER
}

enum GroupMembershipStatus {
  INVITED
  REQUESTED
  ACTIVE
}

enum GroupVisibility {
  PUBLIC
  PRIVATE
}

enum GroupStatus {
  PENDING_APPROVAL
  ACTIVE
  REJECTED
}

enum GroupJoinPolicy {
  INVITE_ONLY
  OPEN
  REQUEST_TO_JOIN
}

enum TaskStatus {
  OPEN
  IN_PROGRESS
  DONE
  ARCHIVED
}

enum TaskVisibility {
  PRIVATE
  PUBLIC
}

enum TaskApprovalStatus {
  PENDING
  APPROVED
  REJECTED
}

enum DigestStatus {
  DRAFT
  PUBLISHED
}

enum HeroNominationStatus {
  DRAFT
  PUBLISHED
}

enum HoursEntrySource {
  ESTIMATED
  MANUAL
}

enum EventRsvpResponse {
  YES
  MAYBE
  NO
}

enum EventVisibility {
  PUBLIC
  GROUP
  PRIVATE
}

enum EventType {
  SERVICE
  EVENT
}

enum EventRecurrenceFrequency {
  NONE
  DAILY
  WEEKLY
}

enum EventRequestStatus {
  PENDING
  APPROVED
  REJECTED
}

enum EventRequestCategory {
  SERVICE
  REHEARSAL
  GATHERING
  OTHER
}

enum RequestStatus {
  SUBMITTED
  ACKNOWLEDGED
  SCHEDULED
  COMPLETED
  CANCELED
}

enum VisibilityScope {
  CLERGY_ONLY
  ADMIN_ALL
  ADMIN_SPECIFIC
}

enum RequestType {
  CONFESSION
  GENERIC
  LITURGICAL
  PRAYER
  TALK_TO_PRIEST
}

enum ChatChannelType {
  ANNOUNCEMENT
  GROUP
  PARISH
}

enum ChatChannelMembershipRole {
  MEMBER
  MODERATOR
}

enum AccessRequestStatus {
  PENDING
  APPROVED
  REJECTED
}

enum EmailType {
  TRANSACTIONAL
  NOTIFICATION
  DIGEST
  ANNOUNCEMENT
}

enum EmailStatus {
  SENT
  FAILED
  SKIPPED
}

enum DeliveryChannel {
  EMAIL
  PUSH
}

enum DeliveryStatus {
  SUCCESS
  FAILURE
}

enum ParishEmailDomainStatus {
  DEFAULT
  PENDING
  VERIFIED
  FAILED
}

enum ParishHubTargetType {
  EXTERNAL
  INTERNAL
}

enum ParishHubVisibility {
  PUBLIC
  LOGGED_IN
}

enum ParishIcon {
  BULLETIN
  MASS_TIMES
  CONFESSION
  WEBSITE
  CALENDAR
  READINGS
  GIVING
  CONTACT
  FACEBOOK
  YOUTUBE
  PRAYER
  NEWS
  REFLECTIONS
}

model Parish {
  id                        String                  @id @default(cuid())
  name                      String
  slug                      String                  @unique
  address                   String?
  timezone                  String                  @default("UTC")
  logoUrl                   String?
  defaultLocale             String                  @default("en")
  createdAt                 DateTime                @default(now())
  emailFromName             String?
  emailFromAddress          String?
  emailReplyTo              String?
  emailDomainStatus         ParishEmailDomainStatus @default(DEFAULT)
  gratitudeSpotlightEnabled Boolean                 @default(true)
  gratitudeSpotlightLimit   Int                     @default(5)
  bronzeHours               Float                   @default(10)
  silverHours               Float                   @default(25)
  goldHours                 Float                   @default(50)
  hubGridEnabled            Boolean                 @default(true)
  hubGridPublicEnabled      Boolean                 @default(false)

  pushSubscriptions PushSubscription[]
  memberships       Membership[]
  accessRequests    AccessRequest[]
  groups            Group[]
  weeks             Week[]
  tasks             Task[]
  events            Event[]
  eventRequests     EventRequest[]
  requests          Request[]
  digests           Digest[]
  announcements     Announcement[]
  chatChannels      ChatChannel[]
  emailLogs         EmailLog[]
  notifications     Notification[]
  mentions          Mention[]
  hoursEntries      HoursEntry[]
  heroNominations   HeroNomination[]
  taskSequence      TaskSequence?
  parishInvites     ParishInvite[]
  hubItems          ParishHubItem[]
  deliveryAttempts  DeliveryAttempt[]
  impersonatedUsers User[]             @relation("ImpersonatedParish")
  auditLogs         AuditLog[]         @relation("ParishAuditLogs")
}

model TaskSequence {
  id        String   @id @default(cuid())
  parishId  String   @unique
  nextValue Int      @default(1)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  parish Parish @relation(fields: [parishId], references: [id], onDelete: Cascade)
}

model ParishHubItem {
  id            String              @id @default(cuid())
  parishId      String
  label         String
  icon          ParishIcon
  targetType    ParishHubTargetType
  targetUrl     String?
  internalRoute String?
  visibility    ParishHubVisibility
  order         Int
  enabled       Boolean             @default(true)
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  parish Parish @relation(fields: [parishId], references: [id], onDelete: Cascade)

  @@unique([parishId, order])
  @@index([parishId])
  @@index([parishId, enabled])
}

model User {
  id                      String        @id @default(cuid())
  email                   String        @unique
  name                    String?
  avatarKey               String?
  passwordHash            String
  activeParishId          String?
  impersonatedParishId    String?
  platformRole            PlatformRole?
  emailVerifiedAt         DateTime?
  notificationsEnabled    Boolean       @default(true)
  weeklyDigestEnabled     Boolean       @default(true)
  notifyMessageInApp      Boolean       @default(true)
  notifyTaskInApp         Boolean       @default(true)
  notifyAnnouncementInApp Boolean       @default(true)
  notifyEventInApp        Boolean       @default(true)
  notifyRequestInApp      Boolean       @default(true)
  volunteerHoursOptIn     Boolean       @default(false)
  birthdayMonth           Int?
  birthdayDay             Int?
  anniversaryMonth        Int?
  anniversaryDay          Int?
  greetingsOptIn          Boolean       @default(false)
  lastLoginAt             DateTime?
  lastSeenAnnouncementsAt DateTime?
  lastSeenEventsAt        DateTime?
  lastSeenTasksAt         DateTime?
  lastSeenRequestsAt      DateTime?
  createdAt               DateTime      @default(now())

  notifications            Notification[]
  mentionsReceived         Mention[]                @relation("MentionRecipient")
  mentionsSent             Mention[]                @relation("MentionActor")
  pushSubscriptions        PushSubscription[]
  memberships              Membership[]
  accessRequests           AccessRequest[]
  groupMemberships         GroupMembership[]
  sentGroupInvites         GroupMembership[]        @relation("GroupInviteActor")
  approvedGroupMemberships GroupMembership[]        @relation("GroupApprovalActor")
  createdGroups            Group[]                  @relation("GroupCreator")
  tasks                    Task[]                   @relation("TaskOwner")
  createdTasks             Task[]                   @relation("TaskCreator")
  completedTasks           Task[]                   @relation("TaskCompletion")
  coordinatedTasks         Task[]                   @relation("TaskCoordinator")
  updatedTasks             Task[]                   @relation("TaskUpdatedBy")
  taskVolunteers           TaskVolunteer[]
  taskComments             TaskComment[]
  taskActivities           TaskActivity[]
  digestsCreated           Digest[]                 @relation("DigestAuthor")
  createdAnnouncements     Announcement[]           @relation("AnnouncementAuthor")
  eventRsvps               EventRsvp[]
  eventReminders           EventReminder[]
  chatMessages             ChatMessage[]
  chatChannelMemberships   ChatChannelMembership[]
  chatPinnedMessages       ChatPinnedMessage[]      @relation("ChatPinnedBy")
  chatReactions            ChatReaction[]
  chatRoomReadStates       ChatRoomReadState[]
  chatPollVotes            ChatPollVote[]
  accounts                 Account[]
  sessions                 Session[]
  emailLogs                EmailLog[]
  passwordResetTokens      PasswordResetToken[]
  emailVerificationTokens  EmailVerificationToken[]
  hoursEntries             HoursEntry[]
  heroNominationsSent      HeroNomination[]         @relation("HeroNominationNominator")
  heroNominationsReceived  HeroNomination[]         @relation("HeroNominationNominee")
  sentParishInvites        ParishInvite[]           @relation("ParishInviteActor")
  eventRequests            EventRequest[]
  decidedEventRequests     EventRequest[]           @relation("EventRequestDecisionBy")
  requestsCreated          Request[]                @relation("RequestCreatedBy")
  requestsAssigned         Request[]                @relation("RequestAssignedTo")
  deliveryAttempts         DeliveryAttempt[]
  impersonatedParish       Parish?                  @relation("ImpersonatedParish", fields: [impersonatedParishId], references: [id], onDelete: SetNull)
  auditLogs                AuditLog[]               @relation("AuditActor")
}

model Notification {
  id          String           @id @default(cuid())
  userId      String
  parishId    String
  type        NotificationType
  title       String
  description String?
  href        String
  createdAt   DateTime         @default(now())
  readAt      DateTime?

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  parish Parish @relation(fields: [parishId], references: [id], onDelete: Cascade)

  @@index([userId, parishId, createdAt])
  @@index([userId, parishId, readAt])
  @@index([userId, type, createdAt])
}

model Mention {
  id              String             @id @default(cuid())
  parishId        String
  mentionedUserId String
  actorUserId     String
  contextType     MentionContextType
  contextId       String
  snippet         String?
  href            String
  createdAt       DateTime           @default(now())

  parish        Parish @relation(fields: [parishId], references: [id], onDelete: Cascade)
  mentionedUser User   @relation("MentionRecipient", fields: [mentionedUserId], references: [id], onDelete: Cascade)
  actorUser     User   @relation("MentionActor", fields: [actorUserId], references: [id], onDelete: Cascade)

  @@index([mentionedUserId, parishId, createdAt])
  @@index([contextType, contextId])
}

model AuditLog {
  id             String      @id @default(cuid())
  actorUserId    String
  targetParishId String
  action         AuditAction
  createdAt      DateTime    @default(now())

  actorUser    User   @relation("AuditActor", fields: [actorUserId], references: [id], onDelete: Cascade)
  targetParish Parish @relation("ParishAuditLogs", fields: [targetParishId], references: [id], onDelete: Cascade)

  @@index([actorUserId, createdAt])
  @@index([targetParishId, createdAt])
}

model Membership {
  id                  String     @id @default(cuid())
  parishId            String
  userId              String
  role                ParishRole @default(MEMBER)
  notifyEmailEnabled  Boolean    @default(true)
  weeklyDigestEnabled Boolean    @default(true)

  parish Parish @relation(fields: [parishId], references: [id])
  user   User   @relation(fields: [userId], references: [id])

  @@unique([parishId, userId])
}

model AccessRequest {
  id        String              @id @default(cuid())
  parishId  String
  userId    String
  status    AccessRequestStatus @default(PENDING)
  createdAt DateTime            @default(now())
  updatedAt DateTime            @updatedAt

  parish    Parish     @relation(fields: [parishId], references: [id], onDelete: Cascade)
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  emailLogs EmailLog[]

  @@unique([parishId, userId])
  @@index([parishId, status])
}

model EventRequest {
  id              String               @id @default(cuid())
  parishId        String
  requesterId     String
  contactName     String
  title           String
  category        EventRequestCategory
  startsAt        DateTime
  endsAt          DateTime
  location        String?
  description     String?
  participants    Int?
  status          EventRequestStatus   @default(PENDING)
  createdAt       DateTime             @default(now())
  updatedAt       DateTime             @updatedAt
  decidedAt       DateTime?
  decidedByUserId String?
  eventId         String?              @unique

  parish    Parish @relation(fields: [parishId], references: [id], onDelete: Cascade)
  requester User   @relation(fields: [requesterId], references: [id], onDelete: Cascade)
  decidedBy User?  @relation("EventRequestDecisionBy", fields: [decidedByUserId], references: [id], onDelete: SetNull)
  event     Event? @relation(fields: [eventId], references: [id], onDelete: SetNull)

  @@index([parishId, status])
  @@index([requesterId])
}

model Request {
  id               String          @id @default(cuid())
  parishId         String
  createdByUserId  String
  assignedToUserId String?
  type             RequestType
  status           RequestStatus   @default(SUBMITTED)
  visibilityScope  VisibilityScope @default(ADMIN_ALL)
  title            String
  details          Json?
  lastReminderAt   DateTime?
  archivedAt       DateTime?
  archivedReason   String?
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt

  parish     Parish @relation(fields: [parishId], references: [id], onDelete: Cascade)
  createdBy  User   @relation("RequestCreatedBy", fields: [createdByUserId], references: [id])
  assignedTo User?  @relation("RequestAssignedTo", fields: [assignedToUserId], references: [id])

  @@index([parishId, status])
  @@index([parishId, createdByUserId])
  @@index([parishId, assignedToUserId])
}

model EmailLog {
  id             String      @id @default(cuid())
  type           EmailType
  template       String
  toEmail        String
  userId         String?
  parishId       String?
  weekId         String?
  joinRequestId  String?
  announcementId String?
  status         EmailStatus
  error          String?
  sentAt         DateTime?
  createdAt      DateTime    @default(now())

  user         User?          @relation(fields: [userId], references: [id], onDelete: SetNull)
  parish       Parish?        @relation(fields: [parishId], references: [id], onDelete: SetNull)
  week         Week?          @relation(fields: [weekId], references: [id], onDelete: SetNull)
  joinRequest  AccessRequest? @relation(fields: [joinRequestId], references: [id], onDelete: SetNull)
  announcement Announcement?  @relation(fields: [announcementId], references: [id], onDelete: SetNull)

  @@unique([parishId, weekId, userId, type], name: "EmailLog_parishId_weekId_userId_type_key")
  @@unique([joinRequestId, toEmail, type], name: "EmailLog_joinRequestId_toEmail_type_key")
  @@index([userId])
  @@index([parishId])
  @@index([weekId])
  @@index([joinRequestId])
  @@index([announcementId])
}

model DeliveryAttempt {
  id                String          @id @default(cuid())
  channel           DeliveryChannel
  status            DeliveryStatus
  parishId          String?
  userId            String?
  target            String?
  template          String?
  context           Json?
  providerMessageId String?
  errorCode         String?
  errorMessage      String?
  createdAt         DateTime        @default(now())

  parish Parish? @relation(fields: [parishId], references: [id], onDelete: SetNull)
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([parishId, createdAt])
  @@index([channel, status, createdAt])
  @@index([userId, createdAt])
}

model PasswordResetToken {
  id        String    @id @default(cuid())
  userId    String
  tokenHash String    @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, expiresAt])
}

model EmailVerificationToken {
  id        String    @id @default(cuid())
  userId    String
  tokenHash String    @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, expiresAt])
}

model ParishInvite {
  id              String     @id @default(cuid())
  parishId        String
  email           String
  role            ParishRole @default(MEMBER)
  tokenHash       String     @unique
  expiresAt       DateTime
  acceptedAt      DateTime?
  revokedAt       DateTime?
  invitedByUserId String?
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt

  parish    Parish @relation(fields: [parishId], references: [id], onDelete: Cascade)
  invitedBy User?  @relation("ParishInviteActor", fields: [invitedByUserId], references: [id], onDelete: SetNull)

  @@index([parishId, email])
  @@index([expiresAt])
}

model Week {
  id        String   @id @default(cuid())
  parishId  String
  startsOn  DateTime
  endsOn    DateTime
  label     String
  createdAt DateTime @default(now())

  parish          Parish           @relation(fields: [parishId], references: [id])
  tasks           Task[]
  events          Event[]
  digest          Digest?
  emailLogs       EmailLog[]
  hoursEntries    HoursEntry[]
  heroNominations HeroNomination[]

  @@unique([parishId, startsOn], name: "parishId_startsOn")
  @@index([parishId, startsOn])
}

model Group {
  id          String          @id @default(cuid())
  parishId    String
  createdById String
  name        String
  avatarKey   String?
  description String?
  visibility  GroupVisibility @default(PUBLIC)
  joinPolicy  GroupJoinPolicy @default(INVITE_ONLY)
  status      GroupStatus     @default(ACTIVE)
  createdAt   DateTime        @default(now())
  archivedAt  DateTime?

  parish       Parish            @relation(fields: [parishId], references: [id])
  createdBy    User              @relation("GroupCreator", fields: [createdById], references: [id])
  memberships  GroupMembership[]
  tasks        Task[]
  events       Event[]
  chatChannels ChatChannel[]
  hoursEntries HoursEntry[]

  @@unique([parishId, name])
}

model GroupMembership {
  id               String                @id @default(cuid())
  groupId          String
  userId           String
  role             GroupRole             @default(PARISHIONER)
  status           GroupMembershipStatus @default(ACTIVE)
  invitedByUserId  String?
  approvedByUserId String?
  invitedEmail     String?
  createdAt        DateTime              @default(now())
  updatedAt        DateTime              @updatedAt

  group      Group @relation(fields: [groupId], references: [id])
  user       User  @relation(fields: [userId], references: [id])
  invitedBy  User? @relation("GroupInviteActor", fields: [invitedByUserId], references: [id])
  approvedBy User? @relation("GroupApprovalActor", fields: [approvedByUserId], references: [id])

  @@unique([groupId, userId])
}

model ChatChannel {
  id          String          @id @default(cuid())
  parishId    String
  groupId     String?
  type        ChatChannelType
  name        String
  description String?
  lockedAt    DateTime?
  createdAt   DateTime        @default(now())

  parish        Parish                  @relation(fields: [parishId], references: [id], onDelete: Cascade)
  group         Group?                  @relation(fields: [groupId], references: [id], onDelete: Cascade)
  messages      ChatMessage[]
  memberships   ChatChannelMembership[]
  pinnedMessage ChatPinnedMessage?
  readStates    ChatRoomReadState[]

  @@index([parishId])
}

model ChatMessage {
  id              String    @id @default(cuid())
  channelId       String
  authorId        String
  parentMessageId String?
  body            String
  mentionEntities Json?
  createdAt       DateTime  @default(now())
  editedAt        DateTime?
  deletedAt       DateTime?

  channel       ChatChannel             @relation(fields: [channelId], references: [id], onDelete: Cascade)
  author        User                    @relation(fields: [authorId], references: [id], onDelete: Cascade)
  parentMessage ChatMessage?            @relation("ChatMessageReplies", fields: [parentMessageId], references: [id], onDelete: SetNull)
  replies       ChatMessage[]           @relation("ChatMessageReplies")
  attachments   ChatMessageAttachment[]
  pinned        ChatPinnedMessage?
  reactions     ChatReaction[]
  poll          ChatPoll?

  @@index([channelId, createdAt, id])
  @@index([parentMessageId])
}

model ChatMessageAttachment {
  id        String   @id @default(cuid())
  messageId String
  url       String
  mimeType  String
  size      Int
  width     Int?
  height    Int?
  createdAt DateTime @default(now())

  message ChatMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@index([messageId])
}

model ChatChannelMembership {
  id        String                    @id @default(cuid())
  channelId String
  userId    String
  role      ChatChannelMembershipRole @default(MEMBER)
  createdAt DateTime                  @default(now())

  channel ChatChannel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user    User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([channelId, userId])
  @@index([userId])
}

model ChatPinnedMessage {
  id         String   @id @default(cuid())
  channelId  String   @unique
  messageId  String   @unique
  pinnedAt   DateTime @default(now())
  pinnedById String

  channel  ChatChannel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  message  ChatMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  pinnedBy User        @relation("ChatPinnedBy", fields: [pinnedById], references: [id], onDelete: Cascade)
}

model ChatReaction {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  emoji     String
  createdAt DateTime @default(now())

  message ChatMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId, emoji])
  @@index([messageId])
  @@index([userId])
}

model ChatRoomReadState {
  id         String   @id @default(cuid())
  roomId     String
  userId     String
  lastReadAt DateTime
  updatedAt  DateTime @updatedAt

  room ChatChannel @relation(fields: [roomId], references: [id], onDelete: Cascade)
  user User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([roomId, userId])
  @@index([userId])
}

model ChatPoll {
  id        String    @id @default(cuid())
  messageId String    @unique
  question  String
  expiresAt DateTime?
  createdAt DateTime  @default(now())

  message ChatMessage      @relation(fields: [messageId], references: [id], onDelete: Cascade)
  options ChatPollOption[]
}

model ChatPollOption {
  id     String @id @default(cuid())
  pollId String
  label  String
  order  Int

  poll  ChatPoll       @relation(fields: [pollId], references: [id], onDelete: Cascade)
  votes ChatPollVote[]

  @@index([pollId])
}

model ChatPollVote {
  id        String   @id @default(cuid())
  optionId  String
  userId    String
  createdAt DateTime @default(now())

  option ChatPollOption @relation(fields: [optionId], references: [id], onDelete: Cascade)
  user   User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([optionId, userId])
  @@index([optionId])
  @@index([userId])
}

model Task {
  id               String             @id @default(cuid())
  displayId        String
  parishId         String
  weekId           String
  groupId          String?
  ownerId          String?
  createdById      String
  title            String
  notes            String?
  estimatedHours   Float?
  volunteersNeeded Int                @default(1)
  status           TaskStatus         @default(OPEN)
  visibility       TaskVisibility     @default(PUBLIC)
  openToVolunteers Boolean            @default(false)
  approvalStatus   TaskApprovalStatus @default(APPROVED)
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  updatedByUserId  String?
  inProgressAt     DateTime?
  completedAt      DateTime?
  dueAt            DateTime?
  completedById    String?
  coordinatorId    String?
  archivedAt       DateTime?
  rolledFromTaskId String?

  parish       Parish          @relation(fields: [parishId], references: [id])
  week         Week            @relation(fields: [weekId], references: [id], onDelete: Cascade)
  group        Group?          @relation(fields: [groupId], references: [id])
  owner        User?           @relation("TaskOwner", fields: [ownerId], references: [id])
  createdBy    User            @relation("TaskCreator", fields: [createdById], references: [id])
  completedBy  User?           @relation("TaskCompletion", fields: [completedById], references: [id])
  coordinator  User?           @relation("TaskCoordinator", fields: [coordinatorId], references: [id])
  updatedBy    User?           @relation("TaskUpdatedBy", fields: [updatedByUserId], references: [id])
  volunteers   TaskVolunteer[]
  comments     TaskComment[]
  activities   TaskActivity[]
  hoursEntries HoursEntry[]

  @@unique([parishId, displayId])
  @@index([weekId])
  @@index([ownerId])
  @@index([createdById])
  @@index([groupId])
  @@index([parishId, weekId])
  @@index([parishId, status])
  @@index([parishId, completedAt])
}

model HoursEntry {
  id             String           @id @default(cuid())
  parishId       String
  weekId         String
  taskId         String
  userId         String
  groupId        String?
  estimatedHours Float?
  hours          Float
  source         HoursEntrySource
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt

  parish Parish @relation(fields: [parishId], references: [id])
  week   Week   @relation(fields: [weekId], references: [id], onDelete: Cascade)
  task   Task   @relation(fields: [taskId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  group  Group? @relation(fields: [groupId], references: [id])

  @@unique([taskId, userId])
  @@index([parishId, weekId])
  @@index([parishId, createdAt])
  @@index([userId])
}

model HeroNomination {
  id            String               @id @default(cuid())
  parishId      String
  weekId        String
  nominatorId   String
  nomineeUserId String
  reason        String
  status        HeroNominationStatus @default(DRAFT)
  createdAt     DateTime             @default(now())
  updatedAt     DateTime             @updatedAt
  publishedAt   DateTime?

  parish    Parish @relation(fields: [parishId], references: [id])
  week      Week   @relation(fields: [weekId], references: [id], onDelete: Cascade)
  nominator User   @relation("HeroNominationNominator", fields: [nominatorId], references: [id])
  nominee   User   @relation("HeroNominationNominee", fields: [nomineeUserId], references: [id])

  @@unique([parishId, weekId, nomineeUserId])
  @@index([parishId, weekId, status])
}

model TaskVolunteer {
  id        String   @id @default(cuid())
  taskId    String
  userId    String
  createdAt DateTime @default(now())

  task Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([taskId, userId])
  @@index([taskId])
  @@index([userId])
}

model TaskComment {
  id              String   @id @default(cuid())
  taskId          String
  authorId        String
  body            String
  mentionEntities Json?
  createdAt       DateTime @default(now())

  task   Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  author User @relation(fields: [authorId], references: [id], onDelete: Cascade)

  @@index([taskId])
  @@index([authorId])
}

model TaskActivity {
  id          String   @id @default(cuid())
  taskId      String
  actorId     String
  description String
  createdAt   DateTime @default(now())

  task  Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  actor User @relation(fields: [actorId], references: [id], onDelete: Cascade)

  @@index([taskId])
  @@index([actorId])
}

model Event {
  id                  String                   @id @default(cuid())
  parishId            String
  weekId              String
  title               String
  startsAt            DateTime
  endsAt              DateTime
  location            String?
  summary             String?
  visibility          EventVisibility          @default(PUBLIC)
  groupId             String?
  type                EventType                @default(EVENT)
  recurrenceFreq      EventRecurrenceFrequency @default(NONE)
  recurrenceInterval  Int                      @default(1)
  recurrenceByWeekday Int[]                    @default([])
  recurrenceUntil     DateTime?
  createdAt           DateTime                 @default(now())
  updatedAt           DateTime                 @updatedAt

  parish       Parish          @relation(fields: [parishId], references: [id])
  week         Week            @relation(fields: [weekId], references: [id], onDelete: Cascade)
  group        Group?          @relation(fields: [groupId], references: [id])
  rsvps        EventRsvp[]
  reminders    EventReminder[]
  eventRequest EventRequest?

  @@index([weekId])
  @@index([parishId, startsAt])
  @@index([parishId, visibility])
}

model EventRsvp {
  id        String            @id @default(cuid())
  eventId   String
  userId    String
  response  EventRsvpResponse
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
  @@index([eventId])
  @@index([userId])
}

model EventReminder {
  id       String   @id @default(cuid())
  eventId  String
  userId   String
  startsAt DateTime
  sentAt   DateTime @default(now())

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId, startsAt])
  @@index([eventId])
  @@index([userId])
  @@index([startsAt])
}

model Digest {
  id          String       @id @default(cuid())
  parishId    String
  weekId      String       @unique
  content     String
  status      DigestStatus @default(DRAFT)
  createdById String
  publishedAt DateTime?

  parish Parish @relation(fields: [parishId], references: [id])
  week   Week   @relation(fields: [weekId], references: [id], onDelete: Cascade)
  author User   @relation("DigestAuthor", fields: [createdById], references: [id])

  @@unique([parishId, weekId])
  @@index([parishId, weekId])
}

model Announcement {
  id              String    @id @default(cuid())
  parishId        String
  title           String
  body            String?
  bodyHtml        String?
  bodyText        String?
  audienceUserIds String[]  @default([])
  createdById     String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  publishedAt     DateTime?
  archivedAt      DateTime?

  parish    Parish     @relation(fields: [parishId], references: [id])
  createdBy User?      @relation("AnnouncementAuthor", fields: [createdById], references: [id])
  emailLogs EmailLog[]

  @@index([parishId, publishedAt])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model PushSubscription {
  id        String   @id @default(cuid())
  userId    String
  parishId  String
  endpoint  String
  p256dh    String
  auth      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  parish Parish @relation(fields: [parishId], references: [id], onDelete: Cascade)

  @@unique([userId, endpoint])
  @@index([userId, parishId])
  @@index([parishId])
}
